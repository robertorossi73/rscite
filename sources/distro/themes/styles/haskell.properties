
# white space
style.haskell.0=$(style.*.32)
# identifier
style.haskell.1=
# keyword
style.haskell.2=$(colour.keyword),bold
# numbers
style.haskell.3=$(colour.number)
# string
style.haskell.4=$(colour.string)
# character
style.haskell.5=$(colour.char)
# class: error not implemented
style.haskell.6=$(colour.error)
# module
style.haskell.7=
# capital
style.haskell.8=
# data: error not implemented
style.haskell.9=$(colour.error)
# import: error not implemented
style.haskell.10=$(colour.error)
# operator
style.haskell.11=$(colour.operator),bold
# instance: error not implemented
style.haskell.12=$(colour.error)
# line comment
style.haskell.13=$(colour.code.comment.line),$(font.code.comment.line)
# block comment
style.haskell.14=$(colour.code.comment.box),$(font.code.comment.box)
# block comment 2
style.haskell.15=$(colour.code.comment.box),$(font.code.comment.box)
# block comment 3
style.haskell.16=$(colour.code.comment.box),$(font.code.comment.box)
# pragma
style.haskell.17=$(colour.preproc)
# preprocessor
style.haskell.18=$(colour.preproc)
# End of line where string is not closed
style.haskell.19=fore:#000000,$(font.monospace),back:#E0C0E0,eolfilled
# Reserved operator
style.haskell.20=$(colour.keyword)

# Available in literatehaskell lexer:
# Literate comment
style.haskell.21=$(colour.code.comment.line),$(font.code.comment.line),italics
# Literate delimiter
style.haskell.22=$(colour.operator)

